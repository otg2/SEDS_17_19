{"paragraphs":[{"text":"%md\n\n### Sequence Consensus\n\nIn this programming assignment you will have to complete the implementation of a Leader-Based Sequence Consensus.\n\nWhen you are done you simply have to export your notebook and then upload it in the \"Programming Exercise 2\" page.\n\n**Things to Remember**:\n1. Basic components such as `FIFOPerfectLink` and `BallotLeaderElection` are already provided. No need to implement them.\n2. Execute the imports defined below **before** compiling your component implementations.\n3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.\n4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. `println(s\"Process $self delivers message $msg\");`\n5. Remember that during the simulation check you can print and observe the simulation time, i.e. with `System.currentTimeMillis()`.\n5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied **before** exporting and submitting the notebook.\n6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)\n\nGood luck! :)","user":"anonymous","dateUpdated":"2017-11-24T00:45:46+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1511483416853_1390921550","id":"20160927-134633_1462429338","dateCreated":"2017-11-24T00:30:16+0000","dateStarted":"2017-11-24T00:45:46+0000","dateFinished":"2017-11-24T00:45:46+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:3937","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Sequence Consensus</h3>\n<p>In this programming assignment you will have to complete the implementation of a Leader-Based Sequence Consensus.</p>\n<p>When you are done you simply have to export your notebook and then upload it in the &ldquo;Programming Exercise 2&rdquo; page.</p>\n<p><strong>Things to Remember</strong>:<br/>1. Basic components such as <code>FIFOPerfectLink</code> and <code>BallotLeaderElection</code> are already provided. No need to implement them.<br/>2. Execute the imports defined below <strong>before</strong> compiling your component implementations.<br/>3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.<br/>4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. <code>println(s&quot;Process $self delivers message $msg&quot;);</code><br/>5. Remember that during the simulation check you can print and observe the simulation time, i.e. with <code>System.currentTimeMillis()</code>.<br/>5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied <strong>before</strong> exporting and submitting the notebook.<br/>6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)</p>\n<p>Good luck! :)</p>\n</div>"}]}},{"text":"import se.kth.edx.id2203.core.ExercisePrimitives.AddressUtils._\nimport se.kth.edx.id2203.core.ExercisePrimitives.AddressUtils\nimport se.sics.kompics.sl._\nimport se.sics.kompics.network._\nimport se.kth.edx.id2203.core.Ports.{SequenceConsensus, _}\nimport se.sics.kompics.KompicsEvent\nimport se.kth.edx.id2203.validation._\n\nimport scala.collection.mutable;\n","user":"anonymous","dateUpdated":"2017-11-24T00:44:08+0000","config":{"lineNumbers":false,"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1511483416854_1392075796","id":"20160830-154917_187608468","dateCreated":"2017-11-24T00:30:16+0000","dateStarted":"2017-11-24T00:44:08+0000","dateFinished":"2017-11-24T00:44:12+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:3938"},{"text":"%md\n\n\nA Sequence Consensus abstraction, in Kompics terms, is a composite component that **provides** the following port *(already imported in the notebook)*.\n\n    class SequenceConsensus extends Port {\n        request[SC_Propose];\n        indication[SC_Decide];\n    }\n  \nIn your implementation, the **Sequence Consensus** component should indicate with a `SC_Decide` message every value that is appended in the decided sequence (invoked in FIFO order) as well as requesting proposed values through a `SC_Propose` message:\n\n    case class SC_Propose(value: RSM_Command) extends KompicsEvent;\n    case class SC_Decide(value: RSM_Command) extends KompicsEvent;\n    \n    trait RSM_Command\n    \n    \n\nYour sequence consensus component builds on top of a `Ballot Leader Election` component (simulated, no need to provide an implementation). That means that it subscribes to `BLE_Leader(Leader, Ballot)` indications whenever a new leader is elected alongside a maximum ballot. \n\nFurthermore, a `FIFOPerfectLink` abstraction is also provided to send and receive messages in FIFO order between every two processes, using the same messages as the PerfectLink port introduced in Part I (i.e., using `PL_Send(destination, payload)` and `PL_Receive(sender, payload)` messages)  \n\nThe following properties define the expected behavior of a consensus abstraction more specifically:\n\n1. **Validity**: *Every value decided in a sequence has been previously proposed*\n2. **Uniform Agreement**: *For every two sequences decided across different processs, one is a prefix of the other.*\n3. **Completeness**: *Every command proposed by a correct process is eventually included in a decided sequence by every correct process.*\n    \nThe recommended algorithm to use is the the one we call \"Leader-Based Sequence Paxos\" which extends and optimises single value paxos to work with sequences of values.\nYou can find the algorithm in the following  <a href=\"https://courses.edx.org/asset-v1:KTHx+ID2203.2x+2016T4+type@asset+block@sequence-paxos.pdf\" target=\"_blank\">document</a>.\n","user":"anonymous","dateUpdated":"2017-11-24T00:45:49+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1511483416854_1392075796","id":"20160930-115754_781424547","dateCreated":"2017-11-24T00:30:16+0000","dateStarted":"2017-11-24T00:45:49+0000","dateFinished":"2017-11-24T00:45:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:3939","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>A Sequence Consensus abstraction, in Kompics terms, is a composite component that <strong>provides</strong> the following port <em>(already imported in the notebook)</em>.</p>\n<pre><code>class SequenceConsensus extends Port {\n    request[SC_Propose];\n    indication[SC_Decide];\n}\n</code></pre>\n<p>In your implementation, the <strong>Sequence Consensus</strong> component should indicate with a <code>SC_Decide</code> message every value that is appended in the decided sequence (invoked in FIFO order) as well as requesting proposed values through a <code>SC_Propose</code> message:</p>\n<pre><code>case class SC_Propose(value: RSM_Command) extends KompicsEvent;\ncase class SC_Decide(value: RSM_Command) extends KompicsEvent;\n\ntrait RSM_Command\n</code></pre>\n<p>Your sequence consensus component builds on top of a <code>Ballot Leader Election</code> component (simulated, no need to provide an implementation). That means that it subscribes to <code>BLE_Leader(Leader, Ballot)</code> indications whenever a new leader is elected alongside a maximum ballot. </p>\n<p>Furthermore, a <code>FIFOPerfectLink</code> abstraction is also provided to send and receive messages in FIFO order between every two processes, using the same messages as the PerfectLink port introduced in Part I (i.e., using <code>PL_Send(destination, payload)</code> and <code>PL_Receive(sender, payload)</code> messages) </p>\n<p>The following properties define the expected behavior of a consensus abstraction more specifically:</p>\n<ol>\n  <li><strong>Validity</strong>: <em>Every value decided in a sequence has been previously proposed</em></li>\n  <li><strong>Uniform Agreement</strong>: <em>For every two sequences decided across different processs, one is a prefix of the other.</em></li>\n  <li><strong>Completeness</strong>: <em>Every command proposed by a correct process is eventually included in a decided sequence by every correct process.</em></li>\n</ol>\n<p>The recommended algorithm to use is the the one we call &ldquo;Leader-Based Sequence Paxos&rdquo; which extends and optimises single value paxos to work with sequences of values.<br/>You can find the algorithm in the following <a href=\"https://courses.edx.org/asset-v1:KTHx+ID2203.2x+2016T4+type@asset+block@sequence-paxos.pdf\" target=\"_blank\">document</a>.</p>\n</div>"}]}},{"text":"\n//Provided Primitives to use in your implementation\n\ncase class Prepare(nL: Long, ld: Int, na: Long) extends KompicsEvent;\ncase class Promise(nL: Long, na: Long, suffix: List[RSM_Command], ld: Int) extends KompicsEvent;\ncase class AcceptSync(nL: Long, suffix: List[RSM_Command], ld: Int) extends KompicsEvent;\ncase class Accept(nL: Long, c: RSM_Command) extends KompicsEvent;\ncase class Accepted(nL: Long, m: Int) extends KompicsEvent;\ncase class Decide(ld: Int, nL: Long) extends KompicsEvent;\n\nobject State extends Enumeration {\n    type State = Value;\n    val PREPARE, ACCEPT, UNKOWN = Value;\n}\n\nobject Role extends Enumeration {\n    type Role = Value;\n    val LEADER, FOLLOWER = Value;\n}\n\ndef suffix(s: List[RSM_Command], l: Int): List[RSM_Command] = {\n    s.drop(l)\n}\n\ndef prefix(s: List[RSM_Command], l: Int): List[RSM_Command] = {\n    s.take(l)\n}","user":"anonymous","dateUpdated":"2017-11-24T00:44:08+0000","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1511483416855_1391691048","id":"20160830-154940_1300846994","dateCreated":"2017-11-24T00:30:16+0000","dateStarted":"2017-11-24T00:44:12+0000","dateFinished":"2017-11-24T00:44:15+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:3940"},{"text":"\nclass SequencePaxos(init: Init[SequencePaxos]) extends ComponentDefinition {\n\nimport Role._\nimport State._\n    \n  val sc = provides[SequenceConsensus];\n  val ble = requires[BallotLeaderElection];\n  val pl = requires[FIFOPerfectLink];\n\n  val (self, pi, others) = init match {\n    case Init(addr: Address, pi: Set[Address] @unchecked) => (addr, pi, pi - addr)\n  }\n  val majority = (pi.size / 2) + 1;\n\n  var state = (FOLLOWER, UNKOWN);\n  var nL = 0l;\n  var nProm = 0l;\n  var leader: Option[Address] = None;\n  var na = 0l;\n  var va = List.empty[RSM_Command];\n  var ld = 0;\n  // leader state\n  var propCmds = List.empty[RSM_Command];\n  val las = mutable.Map.empty[Address, Int];\n  val lds = mutable.Map.empty[Address, Int];\n  var lc = 0;\n  val acks = mutable.Map.empty[Address, (Long, List[RSM_Command])];\n\n\n  ble uponEvent {\n    case BLE_Leader(l, n) => handle {\n        /* INSERT YOUR CODE HERE */  \n    }\n   }\n   \n  pl uponEvent {\n    case PL_Deliver(p, Prepare(np, ldp, n)) => handle {\n      /* INSERT YOUR CODE HERE */\n    }\n    case PL_Deliver(a, Promise(n, na, sfxa, lda)) => handle {\n      if ((n == nL) && (state == (LEADER, PREPARE))) {\n        /* INSERT YOUR CODE HERE */\n      } else if ((n == nL) && (state == (LEADER, ACCEPT))) {\n        /* INSERT YOUR CODE HERE */\n      }\n    }\n    case PL_Deliver(p, AcceptSync(nL, sfx, ldp)) => handle {\n      if ((nProm == nL) && (state == (FOLLOWER, PREPARE))) {\n         /* INSERT YOUR CODE HERE */\n      }\n    }\n    case PL_Deliver(p, Accept(nL, c)) => handle {\n      if ((nProm == nL) && (state == (FOLLOWER, ACCEPT))) {\n         /* INSERT YOUR CODE HERE */\n      }\n    }\n    case PL_Deliver(_, Decide(l, nL)) => handle {\n       /* INSERT YOUR CODE HERE */\n    }\n    case PL_Deliver(a, Accepted(n, m)) => handle {\n      if ((n == nL) && (state == (LEADER, ACCEPT))) {\n         /* INSERT YOUR CODE HERE */}\n      }\n    }\n\n  sc uponEvent {\n    case SC_Propose(c) => handle {\n      if (state == (LEADER, PREPARE)) {\n         /* INSERT YOUR CODE HERE */;\n      } \n      else if (state == (LEADER, ACCEPT)) {\n         /* INSERT YOUR CODE HERE */\n      }\n    }\n  }\n}","user":"anonymous","dateUpdated":"2017-11-24T00:45:21+0000","config":{"lineNumbers":true,"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1511483416855_1391691048","id":"20160830-154952_592749615","dateCreated":"2017-11-24T00:30:16+0000","dateStarted":"2017-11-24T00:45:21+0000","dateFinished":"2017-11-24T00:45:22+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:3941"},{"text":"checkSeqConsensus[SequencePaxos]","user":"anonymous","dateUpdated":"2017-11-24T00:45:25+0000","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1511483416855_1391691048","id":"20160830-155009_392534435","dateCreated":"2017-11-24T00:30:16+0000","dateStarted":"2017-11-24T00:45:25+0000","dateFinished":"2017-11-24T00:45:31+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:3942"},{"user":"anonymous","dateUpdated":"2017-11-24T00:44:08+0000","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":[],"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1511483416855_1391691048","id":"20160830-155043_337959288","dateCreated":"2017-11-24T00:30:16+0000","status":"FINISHED","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:3943"}],"name":"Exercise-Sequence Consensus-Solution","id":"2CYB48SFZ","angularObjects":{"2BKQCVH92:shared_process":[],"2CVXXPNWV:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}