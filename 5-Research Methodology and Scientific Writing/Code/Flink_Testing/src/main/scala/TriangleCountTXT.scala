
import org.apache.flink.api.scala._
import org.apache.flink.graph.scala._
import org.apache.flink.graph.Edge
import org.apache.flink.api.common.functions.MapFunction
import org.apache.flink.api.java.DataSet
import org.apache.flink.graph.spargel.{GatherFunction, MessageIterator, ScatterFunction}
import org.apache.flink.graph.Vertex
import org.apache.flink.graph.library.{GSAConnectedComponents, TriangleEnumerator}
import org.apache.flink.graph.library.clustering.undirected.TriangleListing

import scala.collection.JavaConversions._
import org.apache.flink.graph.scala.utils.Tuple3ToEdgeMap
import org.apache.flink.types.NullValue
import org.joda.time.{DateTime, DateTimeZone}


object TriangleCountTXT {


  case class VertexAttr(srcId: Long, color: Long)

  /**
    *
    * @param srcId srcId of the edge
    * @param dstId dstId of the edge
    * @param dist  distance of the edge
    */
  case class EdgeAttr(srcId: Long, dstId: Long, dist: Double)

  /**
    * Msg that is passed from one node to its neighbors, to indicate colors.
    *
    * Note: This works when number of colors (k) is less than 32  , as int can only contain
    * 32 bits. Since for a graph like, k is  always bounded by its max degree + 1.
    *
    * For a directed street network this could not exceed 10 or (would be in the range of 2-10).
    *
    * For graph with large k , a bit array could be used.
    *
    * @param value
    */
  case class Msg(value: Int)

  /**
    * Aggregator function
    *
    * Each Message with value(int) will keep track of the
    * its neighbors colors (integers) by setting the corresponding bits.
    *
    * For Example
    * A node with neighboring colors as 1,2,3,5 will have a value of  000101110
    * A node with neighboring colors as 0,2,5   will have a value of  000100101
    *
    * All Neighbors , Bitwise or would be
    * 000101110 |
    * 000100101
    * =    000101111
    *
    * Indicating the neighboring colors will be (0,1,2,3,5)
    *
    *
    * This reduction function will save all the neighbors colors by applying a bitwise or
    * operation to all the messages it receives from its neighbors.
    *
    * @param msg1 Int
    * @param msg2 Int
    * @return A new Msg generated by applying bitwise or operation to the msg values.
    */
  def chooseColorMsg(msg1: Int, msg2: Int): Int = {
    msg1 | msg2
  }

  /**
    * The msg will contain neighboring color as bits set in its value.
    * We would like to find the minimum position of the bit which is set to 0 (color not taken)
    *
    * For example , lets assume the value of the msg is 00101011011
    * We would like to return 3, as position of min zero bit 00101011[0]11
    *
    * This is done using the following steps
    *
    * a) Negate the number (ones and zeros will interchange)
    * b) x & ~(x-1) will just set all bits to zero except the lowest set bit.
    * c) Position of the this set bit -1 is the desired position.
    *
    * @param msg Aggregation of all messages received from its neighbors
    * @return min position of the zero bit present in the value of message
    */

  def getMinColor(msg: Int): Int = {

    // Bitwise negation
    val negatedValue = ~msg

    // Position of Least significant bit set in the graph
    var position = negatedValue & ~(negatedValue - 1)
    var count = 0
    while (position > 0) {
      position >>= 1
      count += 1
    }
    count - 1
  }




  def main(args: Array[String]): Unit = {
    print("Hello World")
    val env = ExecutionEnvironment.getExecutionEnvironment

    //val edgeTuples = env.readCsvFile[String, String, Double]("/Users/mohamedgabr/Downloads/datasets/100_JAZZ.txt")

    var edges2 = env.readCsvFile[(Integer, Integer)]("/Users/mohamedgabr/Downloads/arenas-pgp/out.arenas-pgp.csv")

    val edges = edges2.map(x => (x._1, x._2, 1: Integer))


    var graph = Graph.fromTupleDataSet(edges, env)

    var graph2 = graph.mapVertices(v => v.getId)

    val before :Double= System.nanoTime()

    println("BEFORE")
    println(before)

    //val graphupdated3 = graph.run(new TriangleEnumerator[Integer, NullValue, NullValue])

     val graphupdated4 = graph2.run(new GSAConnectedComponents[Integer, Integer, Integer](100))



    val after:Double = System.nanoTime()
    println("AFTER")
    println(after)
    val diff = after - before
    println("Time Difference: ")
    println(diff)

    println(graphupdated4.collect())

    //println("Triangle Count")
    //println(graphupdated3.count())



  }

}







