
import org.apache.flink.api.scala._
import org.apache.flink.graph.scala._
import org.apache.flink.graph.Edge
import org.apache.flink.api.common.functions.MapFunction
import org.apache.flink.api.java.DataSet
import org.apache.flink.graph.spargel.{GatherFunction, MessageIterator, ScatterFunction, ScatterGatherConfiguration}
import org.apache.flink.graph.Vertex

import scala.collection.JavaConversions._
import org.apache.flink.graph.scala.utils.Tuple3ToEdgeMap
import org.joda.time.{DateTime, DateTimeZone}


object FlinkGraphColoringTXT {


  case class VertexAttr(srcId: Long, color: Long)

  /**
    *
    * @param srcId srcId of the edge
    * @param dstId dstId of the edge
    * @param dist  distance of the edge
    */
  case class EdgeAttr(srcId: Long, dstId: Long, dist: Double)

  /**
    * Msg that is passed from one node to its neighbors, to indicate colors.
    *
    * Note: This works when number of colors (k) is less than 32  , as int can only contain
    * 32 bits. Since for a graph like, k is  always bounded by its max degree + 1.
    *
    * For a directed street network this could not exceed 10 or (would be in the range of 2-10).
    *
    * For graph with large k , a bit array could be used.
    *
    * @param value
    */
  case class Msg(value: Int)

  /**
    * Aggregator function
    *
    * Each Message with value(int) will keep track of the
    * its neighbors colors (integers) by setting the corresponding bits.
    *
    * For Example
    * A node with neighboring colors as 1,2,3,5 will have a value of  000101110
    * A node with neighboring colors as 0,2,5   will have a value of  000100101
    *
    * All Neighbors , Bitwise or would be
    * 000101110 |
    * 000100101
    * =    000101111
    *
    * Indicating the neighboring colors will be (0,1,2,3,5)
    *
    *
    * This reduction function will save all the neighbors colors by applying a bitwise or
    * operation to all the messages it receives from its neighbors.
    *
    * @param msg1 Int
    * @param msg2 Int
    * @return A new Msg generated by applying bitwise or operation to the msg values.
    */
  def chooseColorMsg(msg1: Int, msg2: Int): Int = {
    msg1 | msg2
  }

  /**
    * The msg will contain neighboring color as bits set in its value.
    * We would like to find the minimum position of the bit which is set to 0 (color not taken)
    *
    * For example , lets assume the value of the msg is 00101011011
    * We would like to return 3, as position of min zero bit 00101011[0]11
    *
    * This is done using the following steps
    *
    * a) Negate the number (ones and zeros will interchange)
    * b) x & ~(x-1) will just set all bits to zero except the lowest set bit.
    * c) Position of the this set bit -1 is the desired position.
    *
    * @param msg Aggregation of all messages received from its neighbors
    * @return min position of the zero bit present in the value of message
    */

  def getMinColor(msg: Int): Int = {

    // Bitwise negation
    val negatedValue = ~msg

    // Position of Least significant bit set in the graph
    var position = negatedValue & ~(negatedValue - 1)
    var count = 0
    while (position > 0) {
      position >>= 1
      count += 1
    }
    count - 1
  }




  def main(args: Array[String]): Unit = {





    print("Hello World")
    val env = ExecutionEnvironment.getExecutionEnvironment

    //val edgeTuples = env.readCsvFile[String, String, Double]("/Users/mohamedgabr/Downloads/datasets/100_JAZZ.txt")



//    var edges2 = env.readCsvFile[(Int, Int)]("/Users/mohamedgabr/Downloads/flixster/out.flixster.csv")

    var edges2 = env.readCsvFile[(Int, Int)]("/Users/mohamedgabr/Downloads/arenas-jazz/out.arenas-jazz_2.csv")


    def edges = edges2.map(x => (x._1, x._2, 1))


    var graph = Graph.fromTupleDataSet(edges, env)


    var graphupdated = graph.mapVertices(v => v.getId)

    var vertices = graphupdated.getVertices.collect()

    var counter = 0
    for (vertex <- vertices)
    {
      vertex.setValue(counter)
      counter = counter + 1
    }

    var vertices2 = env.fromCollection(vertices)

    var vertices3 = vertices2.map(v => (v.getId, v.getValue))

    var graphupdated2 = Graph.fromTupleDataSet(vertices3, edges, env)

    println(graphupdated2.getVertices.collect())

    var k = graphupdated2.getDegrees().collect()
    var k2 = graphupdated2.getDegrees().collect().maxBy(_._2)._2.toString.toInt


    println("max degree")
    println(k)
    println(k2)


    var maxIterations = 10

    // Execute the scatter-gather iteration


    // messaging
    final class MinDistanceMessenger extends ScatterFunction[Int, Int, Int, Int] {

      override def sendMessages(vertex: Vertex[Int, Int]) = {
        for (edge: Edge[Int, Int] <- getEdges) {
          sendMessageTo(edge.getTarget, vertex.getValue)
        }
      }
    }

    // vertex update
    final class VertexDistanceUpdater extends GatherFunction[Int, Int, Int] {

      override def updateVertex(vertex: Vertex[Int, Int], inMessages: MessageIterator[Int]) = {
        var minDistance = 0
        var entered = false
        while (inMessages.hasNext) {
          val msg = inMessages.next
          if (msg <= k2 + 1 && vertex.getValue > k2 + 1) {
            entered = true
            minDistance = chooseColorMsg(minDistance, 1 << msg)
          }
        }

        if (vertex.getValue > k2+1 && entered) {
          setNewVertexValue(getMinColor(minDistance))
        }
      }
    }

    var before :Double= System.nanoTime()



    println("BEFORE")
    println(before)
//
//    val parameters = new ScatterGatherConfiguration
//    parameters.
//
//      var b = 0
//      for (a<-0 to 100)
//      {

        var result = graphupdated2.runScatterGatherIteration(new MinDistanceMessenger, new VertexDistanceUpdater, 400)
       // graphupdated2 = result
//        b = a
//
//      }

    println(result.getVertices.collect())

    var after:Double = System.nanoTime()
    println("AFTER")
    println(after)
    var diff = after - before
    println("Time Difference: ")
    println(diff)

   // println(b)
    // Extract the vertices as the result

    println("Number of Used Colors")

    println(result.getVertices.distinct(_.getValue).count())


    // - - -  UDFs - - - //


  }

}







