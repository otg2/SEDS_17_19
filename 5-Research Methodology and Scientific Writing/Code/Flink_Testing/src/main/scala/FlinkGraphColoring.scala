

import org.apache.flink.api.scala.ExecutionEnvironment
import org.apache.flink.graph.{Edge, EdgeDirection, ReduceNeighborsFunction, Vertex}
import org.apache.flink.graph.scala.{Graph, NeighborsFunctionWithVertexValue}
import org.apache.flink.streaming.api.scala._
import org.apache.flink.types.NullValue
import org.apache.flink.util.Collector
import org.joda.time.{DateTime, DateTimeZone}

import _root_.scala.collection.mutable.ListBuffer


object FlinkGraphColoring {


  case class VertexAttr(srcId: Long, color: Long)

  /**
    *
    * @param srcId srcId of the edge
    * @param dstId dstId of the edge
    * @param dist distance of the edge
    */
  case class EdgeAttr(srcId: Long, dstId: Long, dist: Double)

  /**
    * Msg that is passed from one node to its neighbors, to indicate colors.
    *
    * Note: This works when number of colors (k) is less than 32  , as int can only contain
    * 32 bits. Since for a graph like, k is  always bounded by its max degree + 1.
    *
    * For a directed street network this could not exceed 10 or (would be in the range of 2-10).
    *
    * For graph with large k , a bit array could be used.
    *
    * @param value
    */
  case class Msg(value:Int)

  /**
    * Aggregator function
    *
    * Each Message with value(int) will keep track of the
    * its neighbors colors (integers) by setting the corresponding bits.
    *
    * For Example
    *     A node with neighboring colors as 1,2,3,5 will have a value of  000101110
    *     A node with neighboring colors as 0,2,5   will have a value of  000100101
    *
    *     All Neighbors , Bitwise or would be
    *              000101110 |
    *              000100101
    *         =    000101111
    *
    *   Indicating the neighboring colors will be (0,1,2,3,5)
    *
    *
    * This reduction function will save all the neighbors colors by applying a bitwise or
    * operation to all the messages it receives from its neighbors.
    *
    * @param msg1 Int
    * @param msg2 Int
    * @return A new Msg generated by applying bitwise or operation to the msg values.
    */
  def chooseColorMsg(msg1: Int, msg2: Int): Int = {
    msg1 | msg2
  }

  /**
    * The msg will contain neighboring color as bits set in its value.
    * We would like to find the minimum position of the bit which is set to 0 (color not taken)
    *
    * For example , lets assume the value of the msg is 00101011011
    * We would like to return 3, as position of min zero bit 00101011[0]11
    *
    * This is done using the following steps
    *
    *  a) Negate the number (ones and zeros will interchange)
    *  b) x & ~(x-1) will just set all bits to zero except the lowest set bit.
    *  c) Position of the this set bit -1 is the desired position.
    *
    * @param msg Aggregation of all messages received from its neighbors
    * @return min position of the zero bit present in the value of message
    */

  def getMinColor(msg: Int): Int = {

    // Bitwise negation
    val negatedValue = ~msg

    // Position of Least significant bit set in the graph
    var position = negatedValue & ~(negatedValue-1)
    var count = 0
    while(position > 0){
      position >>= 1
      count += 1
    }
    count - 1
  }


  def getNeighbors(g: Graph[Int, NullValue, Double], nodenum : Int, s: Int): Array[Boolean] = {

    val edges = g.getEdges.collect()
    val neighbors : Array[Boolean] =  Array.fill(s+1){false}
    for (a <-0 to edges.length-1)
      {
        val edge = edges(a)
        if (edge.getSource == nodenum)
          {
              neighbors(edge.getTarget) = true : Boolean
          }
        else if  (edge.getTarget == nodenum)
          {
              neighbors(edge.getSource) = true : Boolean
          }
      }
    return neighbors
  }

  def checkcolors(neighbors: Array[Boolean], nodecolors: Array[Int]): ListBuffer[Int] = {

    var colors : ListBuffer[Int]  =  ListBuffer[Int]()
    for (a<- 0 to neighbors.length - 1)
      {
        if (neighbors(a))
          {
            colors += nodecolors(a)
          }
      }

    return colors
  }

  def getsmallestcolor(colors: ListBuffer[Int]): Int ={
    var notfound = true
    var counter : Int = 0
    while (notfound)
    {
      if (colors.contains(counter))
        {
          counter = counter + 1
        }
      else
        {
          notfound = false
        }
    }
    return counter
  }

  def GraphColoringFastest( nodes:  List[(Int, String, Double, Double, Int, Int, Int)], connections: List[(Int, Int, Double)] , k: Int, maxIter:Int = 30) : Array[Int] = {

    val env = ExecutionEnvironment.getExecutionEnvironment

    val edges  : List[Edge[Int, Double]] = connections.map(e =>  new Edge(e._1, e._2, e._3))

    val vertices : List[Vertex[Int, NullValue]] = nodes.map(e => new Vertex(e._1, NullValue.getInstance()))

    val graph = Graph.fromCollection[Int, NullValue, Double](vertices : List[Vertex[Int, NullValue]], edges: List[Edge[Int, Double]], env)

    val nodecolors : Array[Int] =  new Array[Int](k+1)

    for (a <-0 to k)
    {
      nodecolors(a) = 2*k
    }

    for (a <- 0 to k)
    {
      val neighs = getNeighbors(graph, a, k)
      val colors = checkcolors(neighs, nodecolors)
      nodecolors(a) = getsmallestcolor(colors)
    }

    return nodecolors

  }

  def CreateGraph( nodes:  List[(Int, String, Double, Double, Int, Int, Int)], connections: List[(Int, Int, Double)] , k: Int, maxIter:Int = 30) : Graph[Int, Int, Double] = {

    val env = ExecutionEnvironment.getExecutionEnvironment

    val edges  : List[Edge[Int, Double]] = connections.map(e =>  new Edge(e._1, e._2, e._3))

    val vertices : List[Vertex[Int, Int]] = nodes.map(e => new Vertex(e._1, e._7))

    val graph = Graph.fromCollection[Int, Int, Double](vertices : List[Vertex[Int, Int]], edges: List[Edge[Int, Double]], env)


    return graph

  }





  def main(args: Array[String]): Unit = {
    print("Hello World")

    val nodes = List(
      (0, "A", 0.0, 0.0, 3, 0,0),
      (1, "a", 1.0, 1.0, 2, 1,1),
      (2, "b", 1.1, 1.0, 1, 1,2),
      (3, "c", 1.2, 1.0, 1, 1,3),
      (4, "d", 1.3, 1.0, 1, 1,4),
      (5, "e", 1.4, 1.0, 1, 1,5),
      (7, "B", 1.5, 1.1, 1, 1,6),
      (8, "C", 1.5, 1.2, 1, 1,7),
      (9, "D", 1.5, 1.3, 1, 1,8),
      (10, "E", 1.5, 1.4, 1, 1,9),
      (11, "F", 1.5, 1.5, 1, 1,10),
      (12, "Bb", 1.5, 2.1, 1, 1,11),
      (13, "Cc", 1.5, 2.2, 1, 1,12),
      (14, "Dd", 1.5, 2.3, 1, 1,13),
      (15, "Ee", 1.5, 2.4, 1, 1,14),
      (16, "Ff", 1.5, 2.5, 1, 1,15),
      (17, "Gg", 1.5, 2.6, 1, 1,16))

    val connections = List(
      (0, 1, 0.7),
      (1, 2, 0.7),
      (2, 3, 0.2),
      (3, 4, 1.2),
      (4, 5, 1.3),
      (1, 7, 0.7),
      (7, 8, 0.4),
      (8, 9, 0.4),
      (9, 10, 0.4),
      (10, 11, 0.8),
      (0, 12, 0.5),
      (12, 13, 0.6),
      (13, 14 , 0.8),
      (14, 15, 0.7),
      (15, 16, 0.8),
      (16, 17, 0.9))
//
//    val colors = GraphColoringFastest(nodes, connections, 17, 30)
//    for (a <- 0 to  colors.length - 1)
//      {
//        print("Node ")
//        print(a)
//        println(colors(a))
//      }

    var mygraph = CreateGraph(nodes, connections, 17, 30)


//
//    def verticesWithSum = mygraph.reduceOnNeighbors(new SumValues, EdgeDirection.ALL)
//    mygraph =  mygraph.joinWithVertices[Int](verticesWithSum, (orginialvalue:Int, tuplevalue: Int) => tuplevalue)
//    println(mygraph.getVertices.collect())


    println(mygraph.getVertices.collect())

    val iters = 30

   for (a <- 0 to iters)
     {
       var before = DateTime.now(DateTimeZone.UTC).getMillis()

       def vertexPairs = mygraph.groupReduceOnNeighbors(new SelectLargeWeightNeighbors, EdgeDirection.ALL)
       var vertexpairs2 = vertexPairs.map(pair => (pair._1.getId,pair._1.getValue))
       //var vertexpairs3 = vertexpairs2.map(pair => (pair.getId, pair.getValue))
       mygraph =  mygraph.joinWithVertices[Int](vertexpairs2, (orginialvalue:Int, tuplevalue: Int) => tuplevalue)

       var after = DateTime.now(DateTimeZone.UTC).getMillis()
       var diff = after - before

        print("Step: ")
        println(a)
        print("Time Difference: ")
        println(diff)
       //println(mygraph.getVertices.collect())


     }


    println("Finished? ?")
    println(mygraph.getVertices.collect())

    // user-defined function to sum the neighbor values
    final class SumValues extends ReduceNeighborsFunction[Int] {
      override def reduceNeighbors(firstNeighbor: Int, secondNeighbor: Int): Int = {
        getMinColor(chooseColorMsg(firstNeighbor, secondNeighbor))
      }
    }

    final class SelectLargeWeightNeighbors extends NeighborsFunctionWithVertexValue[Int, Int, Double,
      (Vertex[Int, Int], Vertex[Int, Int])] {

      override def iterateNeighbors(vertex: Vertex[Int, Int],
                                    neighbors: Iterable[(Edge[Int, Double], Vertex[Int, Int])],
                                    out: Collector[(Vertex[Int, Int], Vertex[Int, Int])]) = {
        var numberformin = 0
        var entered = false
        for (neighbor <- neighbors) {


          if (neighbor._2.getValue <= 4+1 && vertex.getValue > 4+1) {
              entered = true
              numberformin = numberformin | (1 << neighbor._2.getValue)

          }
        }

        if (entered)
          {
            vertex.setValue(getMinColor(numberformin))
          }

        out.collect(vertex, vertex)

      }
    }

  }


}
