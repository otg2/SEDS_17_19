import org.apache.flink.api.scala._
import org.apache.flink.graph.scala._
import org.apache.flink.graph.Edge
import org.apache.flink.api.common.functions.MapFunction
import org.apache.flink.graph.spargel.{GatherFunction, MessageIterator, ScatterFunction}
import org.apache.flink.graph.Vertex

import scala.collection.JavaConversions._
import org.apache.flink.graph.scala.utils.Tuple3ToEdgeMap
import org.joda.time.{DateTime, DateTimeZone}


object FlinkGraphColoring2 {


  case class VertexAttr(srcId: Long, color: Long)

  /**
    *
    * @param srcId srcId of the edge
    * @param dstId dstId of the edge
    * @param dist  distance of the edge
    */
  case class EdgeAttr(srcId: Long, dstId: Long, dist: Double)

  /**
    * Msg that is passed from one node to its neighbors, to indicate colors.
    *
    * Note: This works when number of colors (k) is less than 32  , as int can only contain
    * 32 bits. Since for a graph like, k is  always bounded by its max degree + 1.
    *
    * For a directed street network this could not exceed 10 or (would be in the range of 2-10).
    *
    * For graph with large k , a bit array could be used.
    *
    * @param value
    */
  case class Msg(value: Int)

  /**
    * Aggregator function
    *
    * Each Message with value(int) will keep track of the
    * its neighbors colors (integers) by setting the corresponding bits.
    *
    * For Example
    * A node with neighboring colors as 1,2,3,5 will have a value of  000101110
    * A node with neighboring colors as 0,2,5   will have a value of  000100101
    *
    * All Neighbors , Bitwise or would be
    * 000101110 |
    * 000100101
    * =    000101111
    *
    * Indicating the neighboring colors will be (0,1,2,3,5)
    *
    *
    * This reduction function will save all the neighbors colors by applying a bitwise or
    * operation to all the messages it receives from its neighbors.
    *
    * @param msg1 Int
    * @param msg2 Int
    * @return A new Msg generated by applying bitwise or operation to the msg values.
    */
  def chooseColorMsg(msg1: Int, msg2: Int): Int = {
    msg1 | msg2
  }

  /**
    * The msg will contain neighboring color as bits set in its value.
    * We would like to find the minimum position of the bit which is set to 0 (color not taken)
    *
    * For example , lets assume the value of the msg is 00101011011
    * We would like to return 3, as position of min zero bit 00101011[0]11
    *
    * This is done using the following steps
    *
    * a) Negate the number (ones and zeros will interchange)
    * b) x & ~(x-1) will just set all bits to zero except the lowest set bit.
    * c) Position of the this set bit -1 is the desired position.
    *
    * @param msg Aggregation of all messages received from its neighbors
    * @return min position of the zero bit present in the value of message
    */

  def getMinColor(msg: Int): Int = {

    // Bitwise negation
    val negatedValue = ~msg

    // Position of Least significant bit set in the graph
    var position = negatedValue & ~(negatedValue - 1)
    var count = 0
    while (position > 0) {
      position >>= 1
      count += 1
    }
    count - 1
  }


  def CreateGraph(nodes: List[(Int, String, Double, Double, Int, Int, Int)], connections: List[(Int, Int, Int)], k: Int, maxIter: Int = 30): Graph[Int, Int, Int] = {

    val env = ExecutionEnvironment.getExecutionEnvironment

    val edges: List[Edge[Int, Int]] = connections.map(e => new Edge(e._1, e._2, e._3))

    val vertices: List[Vertex[Int, Int]] = nodes.map(e => new Vertex(e._1, e._7))

    val graph = Graph.fromCollection[Int, Int, Int](vertices: List[Vertex[Int, Int]], edges: List[Edge[Int, Int]], env)



    return graph

  }


  def main(args: Array[String]): Unit = {
    print("Hello World")

    val nodes = List(
      (0, "A", 0.0, 0.0, 3, 0, 0),
      (1, "a", 1.0, 1.0, 2, 1, 1),
      (2, "b", 1.1, 1.0, 1, 1, 2),
      (3, "c", 1.2, 1.0, 1, 1, 3),
      (4, "d", 1.3, 1.0, 1, 1, 4),
      (5, "e", 1.4, 1.0, 1, 1, 5),
      (7, "B", 1.5, 1.1, 1, 1, 6),
      (8, "C", 1.5, 1.2, 1, 1, 7),
      (9, "D", 1.5, 1.3, 1, 1, 8),
      (10, "E", 1.5, 1.4, 1, 1, 9),
      (11, "F", 1.5, 1.5, 1, 1, 10),
      (12, "Bb", 1.5, 2.1, 1, 1, 11),
      (13, "Cc", 1.5, 2.2, 1, 1, 12),
      (14, "Dd", 1.5, 2.3, 1, 1, 13),
      (15, "Ee", 1.5, 2.4, 1, 1, 14),
      (16, "Ff", 1.5, 2.5, 1, 1, 15),
      (17, "Gg", 1.5, 2.6, 1, 1, 16))

    val connections = List(
      (0, 1, 1),
      (1, 2, 1),
      (2, 3, 1),
      (3, 4, 1),
      (4, 5, 1),
      (1, 7, 1),
      (7, 8, 1),
      (8, 9, 1),
      (9, 10, 1),
      (10, 11, 1),
      (0, 12, 1),
      (12, 13, 1),
      (13, 14, 1),
      (14, 15, 1),
      (15, 16, 1),
      (16, 17, 1))
    //
    //    val colors = GraphColoringFastest(nodes, connections, 17, 30)
    //    for (a <- 0 to  colors.length - 1)
    //      {
    //        print("Node ")
    //        print(a)
    //        println(colors(a))
    //      }

    def graph = CreateGraph(nodes, connections, 17, 30)


    println(graph.getVertices.collect())

    def maxIterations = 30

    // Execute the scatter-gather iteration

    var before = DateTime.now(DateTimeZone.UTC).getMillis()


    def result = graph.runScatterGatherIteration(new MinDistanceMessenger, new VertexDistanceUpdater, maxIterations)


    def after = DateTime.now(DateTimeZone.UTC).getMillis()
    def diff = after - before
    print("Time Difference: ")
    println(diff)

    // Extract the vertices as the result

    print(result.getVertices.collect())


    // - - -  UDFs - - - //

    // messaging
    final class MinDistanceMessenger extends ScatterFunction[Int, Int, Int, Int] {

      override def sendMessages(vertex: Vertex[Int, Int]) = {
        for (edge: Edge[Int, Int] <- getEdges) {
          sendMessageTo(edge.getTarget, vertex.getValue)
        }
      }
    }

    // vertex update
    final class VertexDistanceUpdater extends GatherFunction[Int, Int, Int] {

      override def updateVertex(vertex: Vertex[Int, Int], inMessages: MessageIterator[Int]) = {
        var minDistance = 0
        var entered = false
        while (inMessages.hasNext) {
          val msg = inMessages.next
          if (msg <= 4 + 1 && vertex.getValue > 4 + 1) {
            entered = true
            minDistance = chooseColorMsg(minDistance, 1 << msg)
          }
        }

        if (vertex.getValue > minDistance && entered) {
          setNewVertexValue(getMinColor(minDistance))
        }
      }
    }

  }

}







